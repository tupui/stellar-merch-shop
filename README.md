# Scaffold Stellar Frontend

_To get started with Scaffold Stellar, visit its repo: [github.com/theahaco/scaffold-stellar](https://github.com/theahaco/scaffold-stellar)._

_Under active development._

A modern, up-to-date toolkit for building Stellar smart contract frontends.

- ‚ö°Ô∏è Vite + React + TypeScript
- üîó Auto-generated contract clients
- üß© Example components for contract interaction
- üõ† Hot reload for contract changes
- üß™ Easy local/testnet deployment

This is the starter frontend generated by `stellar scaffold init`. See more at [Scaffold Stellar](https://github.com/theahaco/scaffold-stellar).

## Requirements

Before getting started, make sure you‚Äôve met the requirements listed in the [Soroban documentation](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup) and that the following tools are installed :

- [Rust](https://www.rust-lang.org/tools/install)
- [Cargo](https://doc.rust-lang.org/cargo/) (comes with Rust)
- Rust target: install the compilation target listed in the [Soroban setup guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup)
- [Node.js](https://nodejs.org/en/download/package-manager) (v22, or higher)
- [npm](https://www.npmjs.com/): Comes with the node installer or can also be installed package managers such as Homebrew, Chocolatey, apt, etc.
- [Stellar CLI](https://github.com/stellar/stellar-core)
- [Scaffold Stellar CLI Plugin](https://github.com/AhaLabs/scaffold-stellar)

## Quick Start

To get started with a fresh Scaffold Stellar project, follow the steps below:

1. Initialize a new project:

```bash
stellar scaffold init my-project
cd my-project
```

2. Set up your development environment:

```bash
# Copy and configure environment variables like network and STELLAR_SCAFFOLD_ENV
cp .env.example .env

# Install frontend dependencies
npm install
```

Have a look at `environments.toml` for more fined-grained control.

3. Start development environment:

```bash
npm run dev
```

Open the server URL in your web browser.

4. For testnet/mainnet deployment:

When you are ready for testnet, you need to deploy your contract using
`stellar registry`. Some commands to get you started.

```bash
#  Note --source-account argument is omitted for clarity

# First publish your contract to the registry
stellar registry publish

# Then deploy an instance with constructor parameters
stellar registry deploy \
  --deployed-name my-contract \
  --published-name my-contract \
  -- \
  --param1 value1

# Can access the help docs with --help
stellar registry deploy \
  --deployed-name my-contract \
  --published-name my-contract \
  -- \
  --help

# Install the deployed contract locally
stellar registry create-alias my-contract
```

## Scaffold Initial Project Structure

When you run `stellar scaffold init`, it creates a frontend-focused project structure with example contracts:

```
my-project/                      # Your initialized project
‚îú‚îÄ‚îÄ contracts/                   # Example smart contracts
‚îú‚îÄ‚îÄ packages/                    # Auto-generated TypeScript clients
‚îú‚îÄ‚îÄ src/                         # Frontend React application
‚îÇ   ‚îú‚îÄ‚îÄ components/              # React components
‚îÇ   ‚îú‚îÄ‚îÄ contracts/               # Contract interaction helpers
‚îÇ   ‚îú‚îÄ‚îÄ debug/                   # Debugging contract explorer
‚îÇ   ‚îú‚îÄ‚îÄ hooks/                   # Custom React hooks
‚îÇ   ‚îú‚îÄ‚îÄ pages/                   # App Pages
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx                  # Main application component
‚îÇ   ‚îî‚îÄ‚îÄ main.tsx                 # Application entry point
‚îú‚îÄ‚îÄ target/                      # Build artifacts and WASM files
‚îú‚îÄ‚îÄ environments.toml            # Environment configurations
‚îú‚îÄ‚îÄ package.json                 # Frontend dependencies
‚îî‚îÄ‚îÄ .env                         # Local environment variables
```

This template provides a ready-to-use frontend application with example smart contracts and their TypeScript clients. You can use these as reference while building your own contracts and UI. The frontend is set up with Vite, React, and includes basic components for interacting with the contracts.

## NFC Integration

This project includes desktop-only NFC chip integration for admin operations (chip initialization and management) using Infineon SECORA Blockchain NFC chips. For mobile minting, see the standalone iOS app in `NFCBridge/`.

**Features:**
- Desktop USB reader support (WebSocket)
- SEP-53 compliant contract authentication
- Hardware-secured signatures via secp256k1

**Quick Start:**
- See [README_NFC.md](README_NFC.md) for complete setup and usage guide
- See [DEVELOPMENT.md](DEVELOPMENT.md) for technical architecture details

**Running with NFC:**
```bash
# Start NFC server (Desktop) + dev server
npm run dev:with-nfc

# Or start separately
npm run nfc-server  # Terminal 1
npm run dev         # Terminal 2
```

## iOS App Configuration

The iOS app (`Chimp/`) reads network and contract ID from **Xcode build settings**, which should be synced from the `.env` file.

### Build Configuration (Required)

The app uses build settings that should match your `.env` file:

1. **Open `Chimp.xcodeproj` in Xcode**
2. **Select the Chimp project** ‚Üí **Chimp target** ‚Üí **Build Settings** tab
3. **Search for `STELLAR`** in the search box
4. **Set the following values** (matching your `.env` file):
   - `STELLAR_NETWORK`: `testnet` or `mainnet` (default: `testnet`)
   - `STELLAR_CONTRACT_ID_TESTNET`: Value from `PUBLIC_STELLAR_MERCH_SHOP_CONTRACT_ID_TESTNET` in `.env`
   - `STELLAR_CONTRACT_ID_MAINNET`: Value from `PUBLIC_STELLAR_MERCH_SHOP_CONTRACT_ID_MAINNET` in `.env`

**Example values** (from `.env.example`):
- `STELLAR_NETWORK`: `testnet`
- `STELLAR_CONTRACT_ID_TESTNET`: `CCLRCNSJUU4PPTBHIW4UXWU5NTCLNZOPZQD4XRERFG2PUNLZ3BKSSFHJ`
- `STELLAR_CONTRACT_ID_MAINNET`: `CCLRCNSJUU4PPTBHIW4UXWU5NTCLNZOPZQD4XRERFG2PUNLZ3BKSSFHJ`

### Runtime Override (Optional)

The app also supports runtime override via the Settings view:
1. **Open the iOS app** and navigate to Settings (gear icon in top right)
2. **Select Network**: Choose between Testnet or Mainnet (overrides build config)
3. **Enter Contract ID**: Paste the contract ID (overrides build config)
4. **Save**: Tap the "Save" button to store your settings

Runtime settings take precedence over build configuration and are stored in UserDefaults.

See `Chimp/README_CONFIG.md` for detailed configuration instructions.

### Important: Contract Updates

When deploying a new contract version, you must update the contract ID in **four places**:

1. **Webapp `.env` file**: Update the appropriate network variable:
   - `PUBLIC_STELLAR_MERCH_SHOP_CONTRACT_ID_TESTNET` for testnet
   - `PUBLIC_STELLAR_MERCH_SHOP_CONTRACT_ID_MAINNET` for mainnet
   - `PUBLIC_STELLAR_MERCH_SHOP_CONTRACT_ID_LOCAL` for local development

2. **Webapp `.env.example` file**: Update the example values for other developers

3. **iOS App Build Settings**: Update Xcode build settings:
   - `STELLAR_CONTRACT_ID_TESTNET` for testnet
   - `STELLAR_CONTRACT_ID_MAINNET` for mainnet
   - See `Chimp/README_CONFIG.md` for detailed instructions

4. **iOS App Settings (Optional)**: Can also be updated in the app's Settings view for runtime override

### SEP-53 Flow and ID Recovery

The iOS app implements the SEP-53 standard for contract authentication:

1. **Read Chip**: App reads the public key from the NFC chip
2. **Get Nonce**: App queries the contract for the current nonce for that public key
3. **Create Message**: App creates a SEP-53 compliant message (network hash || contract ID || function name || args || nonce)
4. **Sign with Chip**: NFC chip signs the message hash using secp256k1
5. **Recovery ID**: App tries recovery IDs 1, 0, 2, 3 in sequence. The contract validates signatures and rejects invalid ones, so the app iterates until finding the correct recovery ID.
6. **Build Transaction**: App builds the Soroban transaction with all authentication data
7. **Sign Transaction**: App signs the transaction with the user's wallet private key (stored securely in Keychain)
8. **Submit**: Transaction is submitted to the network

The private key is stored securely using iOS Keychain with Secure Enclave protection (`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`), ensuring it never leaves the device.
